
#include <iostream>
//#include <catch.hpp>
//#include <execution>
#include <sstream>
#include <string>
#include <fstream>
#include <string>
#include <vector>
#include <bitset>
#include <cmath>
#include <random>
#include <boost/dynamic_bitset.hpp>

#include <mockturtle/networks/klut.hpp>
#include <mockturtle/networks/aig.hpp>
#include <mockturtle/networks/xag.hpp>
#include <mockturtle/io/truth_reader.hpp>


//#include <mockturtle/networks/cover.hpp>
#include <mockturtle/algorithms/klut_to_graph.hpp>

//#include <mockturtle/networks/pla2.hpp>// plaT for bottom, plaT0 for only greedy
//#include <mockturtle/networks/plaT0.hpp>
#include <lorina/truth.hpp>
#include <mockturtle/views/names_view.hpp>
#include <mockturtle/algorithms/lfe/graph_to_lfe.hpp>
#include <typeinfo>
#include <lorina/lorina.hpp>
#include <mockturtle/views/depth_view.hpp>

#include <kitty/constructors.hpp>
#include <kitty/print.hpp>
#include <kitty/dynamic_truth_table.hpp>
#include <kitty/statistics.hpp>
#include <fstream>
#include <string>
#include <omp.h>
#include <unistd.h>
using namespace mockturtle;
void print_LFE( lfeNtk<klut_network> LFE, bool only_complete = false )  
{
  std::cout << "complete:" << std::endl;
  for( auto x : LFE.complete.first)
  {
    kitty::print_binary(x);std::cout<<std::endl;
  }
  auto n = LFE.complete.first[0].num_bits();
  for( auto i = 0u; i < n; ++i )
    std::cout << "-";
  std::cout << std::endl;
  for( auto x : LFE.complete.second)
  {
    kitty::print_binary(x);std::cout<<std::endl;
  } 
  if( !only_complete )
  {
    std::cout << "partial:" << std::endl;
    for( auto x : LFE.partial.first)
    {
      std::cout << x <<std::endl;
    }
    n = LFE.partial.first[0].size();
    for( auto i = 0u; i < n; ++i )
      std::cout << "-";
    std::cout << std::endl;

    std::cout << LFE.partial.second <<std::endl; 
  }
}

std::pair<std::vector<kitty::dynamic_truth_table>, uint32_t> load( std::string file_name )
{

  std::string line;
  std::ifstream myfile ( file_name );
  std::vector<kitty::dynamic_truth_table> tts;
  uint64_t n;
  if (myfile.is_open())
  {
    while ( getline (myfile,line) )
    {
        std::cout << line << std::endl;
        std::cout << "2^n: " << line.size() << std::endl;
        n = log2(line.size());
        std::cout << "n: " << n << std::endl;
        kitty::dynamic_truth_table tt(n);
        kitty::create_from_binary_string( tt, line );
        tts.push_back( tt );
        kitty::print_binary(tt);
        std::cout<<std::endl;
    }
    myfile.close();
    for( auto tt : tts )
    {
        print_binary(tt); std::cout << std::endl;
    }
  }
  else std::cout << "Unable to open file";
  return std::make_pair(tts,n);
}
int main()
{
std::cout << "NUM THREADS = " << omp_get_max_threads() << std::endl;
omp_set_num_threads( 1 );

std::vector<size_t> bvect = { 0,1,2,3 };

#pragma omp parallel for 
for (uint32_t i = 0 ; i<bvect.size(); i++) {
  uint32_t bsk = bvect[i];
  std::string str_code;
  if( bsk < 10 )
    str_code = "0"+std::to_string(bsk);
  else
    str_code = std::to_string(bsk);

  std::string path = "/home/acostama/projects/EPFL/mockturtle/benchmarks/NPN-representatives/ex"+str_code+".truth";

  muesli_params ps;
  ps.max_sup = 2;
  klut_network klut;
  if( lorina::read_truth( path, truth_reader( klut ) ) == lorina::return_code::parse_error )
    assert( false );

  auto LFE_pre = graph_to_lfe( klut );
  print_LFE( LFE_pre, true );
  klut = muesli( LFE_pre.partial.first, LFE_pre.partial.second, ps );

  auto xag = convert_klut_to_graph<xag_network>( klut );
  auto LFE_after = graph_to_lfe( klut );
  bool error = false;
  if( LFE_pre.partial.second != LFE_after.partial.second )
  {
    error = true;
    std::cout << "XXXXXXXXXXXXX ERROR XXXXXXXXXXXXX" << std::endl;
  }

  depth_view_params psD;
  psD.count_complements = true;
  depth_view depth_xag{xag, {}, psD};

  std::cout <<".b " << str_code << std::endl;
  std::cout << ".g " << depth_xag.num_gates() << std::endl;
  std::cout << ".s " << depth_xag.size() << std::endl; 
  std::cout << ".d " << depth_xag.depth() << std::endl;
  
  depth_xag.foreach_node( [&]( auto const& n, auto index ) {

      if( !xag.is_pi( n ) )
      {
        for( auto c : xag._storage->nodes[n].children )
        {
          if( depth_xag.is_complemented( c ) )
            std::cout << "!" << c.index << " ";
          else
            std::cout << c.index << " ";
        }
        if( depth_xag.is_xor( n ) )
          std::cout << " XOR " << std::endl;
        else if ( depth_xag.is_and( n ) )
          std::cout << " AND " << std::endl;
        else if ( depth_xag.is_or( n ) )
          std::cout << " OR " << std::endl;
        else
          std::cout << " # " << std::endl;
      }
    } );


}
  return 0;
}