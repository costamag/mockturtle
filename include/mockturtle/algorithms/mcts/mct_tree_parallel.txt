/* mockturtle: C++ logic network library
 * Copyright (C) 2018-2022  EPFL
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*!
  \file mct_tree.hpp
  \brief generic monte carlo tree search engine

  \author Andrea Costamagna
*/
#pragma once

#include "ml_rng.hpp"
#include "mct_utils.hpp"

#include <thread>
#include <mutex>

#include <stdio.h>
#include <stack>
#include <iostream>

namespace mockturtle
{

namespace mcts
{

#pragma region mutex
std::atomic<uint32_t> sim_id{0};
#pragma endregion

using DTT = kitty::dynamic_truth_table;

struct mct_ps
{
    int nIters = 1;
    int nSims = 1;
    bool verbose = false;
    int thresh_nd{1000};

};

struct mct_stats
{
    std::vector<double> times;
    std::vector<double> costs;
    std::vector<int> iters;
    std::vector<int> sims;
    double duration;
};

template<class NODE, template<class> class METHOD>
class mct_tree_t
{
    public:
        std::vector<NODE> nodes;
        METHOD<NODE> method;
        mct_ps ps;

        /* CONSTRUCT/DESCTRUCT */
        mct_tree_t( NODE, METHOD<NODE>, mct_ps );
        mct_tree_t(){};
        ~mct_tree_t(){};

        /* GROW */
        int add_node( int, NODE );
        int select();
        int expand( int );
        int simulate( int );
        std::vector<NODE> simulate( NODE );
        int add_path_to_tree( int, std::vector<NODE> );
        void backpropagate( int, double );

        int solve();
        int solve( mct_stats * );
        void path_print( int );

        double evaluate( int );
        std::vector<NODE> get_path( int );

};

template<class NODE, template<class> class METHOD>
mct_tree_t<NODE, METHOD>::mct_tree_t( NODE root, METHOD<NODE> method, mct_ps ps ) : method(method), ps(ps)
{
    nodes.push_back( root );
}

template<class NODE, template<class> class METHOD>
int mct_tree_t<NODE, METHOD>::select()
{
    return method.select( &nodes );
}

template<class NODE, template<class> class METHOD>
int mct_tree_t<NODE, METHOD>::add_node( int id, NODE child )
{
    if( child.is_null() )   return -1;

    child.id = nodes.size();
    nodes.push_back( child );
    nodes[id].add_child( child.id );
    nodes[child.id].idPar = id;
    return child.id;
}

template<class NODE, template<class> class METHOD>
int mct_tree_t<NODE, METHOD>::add_path_to_tree( int id, std::vector<NODE> path )
{
    NODE nd = nodes[id];
    for( uint32_t i{0}; i<path.size(); ++i )
    {
        path[i].id = nodes.size();
        nodes.push_back( path[i] );
        nodes[id].add_child( path[i].id );
        nodes[path[i].id].idPar = id;
        id = path[i].id;
    }
    return id;
}

template<class NODE, template<class> class METHOD>
int mct_tree_t<NODE, METHOD>::expand( int id )
{
    NODE nd = method.expand( &nodes[id] );
    return add_node( id, nd );
}

template<class NODE, template<class> class METHOD>
int mct_tree_t<NODE, METHOD>::simulate( int id )
{
    NODE nd;
    while( !nodes[id].is_leaf() && !nodes[id].is_null() )
    {
        nd = method.simulate( &nodes[id] );
        if( nd.is_null() ) return -1;
        id = add_node( id, nd );
    }
    return id;
}

template<class NODE, template<class> class METHOD>
std::vector<NODE> mct_tree_t<NODE, METHOD>::simulate( NODE nd )
{
    std::vector<NODE> nds;
    while( !nd.is_leaf() && !nd.is_null() )
    {
        nd = method.simulate( &nd );
        if( nd.is_null() )
        {
            nds.clear();
            return nds;
        }
        nds.push_back( nd );
    }
    return nds;
}

template<class NODE, template<class> class METHOD>
void mct_tree_t<NODE, METHOD>::backpropagate( int id, double cost )
{
    method.backpropagate( &nodes, id, cost );
}

template<class NODE, template<class> class METHOD>
void thread_run( mct_tree_t<NODE, METHOD> * pTree, std::vector<int> vNd0, std::vector<std::vector<NODE>> * pPaths )
{
    int it = sim_id;
    while( it < pTree->ps.nSims )
    {
        int idExp = vNd0[it];
        if( idExp < 0 ) continue;
        if( !pTree->nodes[idExp].is_leaf() )
            (*pPaths[it]) = simulate( pTree->nodes[idExp] );
        it = sim_id++;
    }
}

template<class NODE, template<class> class METHOD>
int mct_tree_t<NODE, METHOD>::solve()
{
    const auto processor_count = std::thread::hardware_concurrency();

    int idBest = -1;
    double bestCost = 100000;
    for( int it{0}; it<ps.nIters; ++it )
    {
        bool FoundLeaf{false};
        int idEnd;
        //if(ps.verbose)  printf("iter %d :", it );
        int idSel = 0;//select();
        if( nodes[idSel].is_leaf() ) { FoundLeaf = true; idEnd = idSel;}
        if( nodes[idSel].is_null() ) { continue; }
        int idExp;
        if( !FoundLeaf )
        {
            idExp = expand( idSel );
            if( idExp < 0 || nodes[idExp].is_null() ) { continue; }
            if( nodes[idExp].is_leaf() ) { FoundLeaf = true; idEnd = idExp; }
        }
        if( FoundLeaf )
        {
            double cost = evaluate( idEnd );
            //backpropagate( idEnd, cost );
            if( cost >= 0 && cost < bestCost )
            {
                idBest = idEnd;
                bestCost = cost;
            }
        }
        else
        {
            std::vector<std::vector<NODE>> paths;
            std::vector<int> vNd0;
            for( int itSim{0}; itSim<ps.nSims; ++itSim )
            {
                paths.emplace_back();
                vNd0.push_back(expand( idExp ));
            }

            
            sim_id.store( 0 );
            std::vector<std::thread> threads;

            for ( auto i = 0u; i < processor_count; ++i )
              threads.push_back( thread_run( this, vNd0, &paths ));//, ps_contest, run_only_one );

            for ( auto i = 0u; i < processor_count; ++i )
              threads[i].join();

            for( int itSim{0}; itSim<ps.nSims; ++itSim )
            {
                idExp = vNd0[itSim];
                if( idExp < 0 ) continue;
                if( !nodes[idExp].is_leaf() )
                    idExp = add_path_to_tree( idExp, paths[itSim] );

                double cost = evaluate( idExp );
                //backpropagate( idEnd, cost );

                if(ps.verbose)  printf("%f ", cost);

                if( cost >= 0 && cost < bestCost )
                {
                    idBest = idExp;
                    bestCost = cost;
                }
            }
        }
        if(ps.verbose)  printf("\n");
    }
    return idBest;
}

template<class NODE, template<class> class METHOD>
int mct_tree_t<NODE, METHOD>::solve( mct_stats * pStats )
{
    const auto processor_count = std::thread::hardware_concurrency();

    std::clock_t start;
    double duration;
    start = std::clock();

    int idBest = -1;
    double bestCost = 100000;
    for( int it{0}; it<ps.nIters; ++it )
    {
        bool FoundLeaf{false};
        int idEnd;
        //if(ps.verbose)  printf("iter %d :", it );
        int idSel = 0;//select();
        if( nodes[idSel].is_leaf() ) { FoundLeaf = true; idEnd = idSel;}
        if( nodes[idSel].is_null() ) { continue; }
        int idExp;
        if( !FoundLeaf )
        {
            idExp = expand( idSel );
            if( idExp < 0 || nodes[idExp].is_null() ) { continue; }
            if( nodes[idExp].is_leaf() ) { FoundLeaf = true; idEnd = idExp; }
        }
        if( FoundLeaf )
        {
            double cost = evaluate( idEnd );
            //backpropagate( idEnd, cost );
            if( cost >= 0 && cost < bestCost )
            {
                idBest = idEnd;
                bestCost = cost;
            }
        }
        else
        {
            std::vector<std::vector<NODE>> paths;
            std::vector<int> vNd0;
            for( int itSim{0}; itSim<ps.nSims; ++itSim )
            {
                paths.emplace_back();
                vNd0.push_back(expand( idExp ));
            }

            sim_id.store( 0 );
            std::vector<std::thread> threads;

            for ( auto i = 0u; i < processor_count; ++i )
              threads.push_back( thread_run( this, vNd0, &paths ));

            for ( auto i = 0u; i < processor_count; ++i )
              threads[i].join();

            for( int itSim{0}; itSim<ps.nSims; ++itSim )
            {
                idExp = vNd0[itSim];
                if( idExp < 0 ) continue;
                if( !nodes[idExp].is_leaf() )
                    idExp = add_path_to_tree( idExp, paths[itSim] );

                double cost = evaluate( idExp );
                //backpropagate( idEnd, cost );

                if(ps.verbose)  printf("%f ", cost);

                if( cost >= 0 && cost < bestCost )
                {
                    pStats->costs.push_back(cost);
                    pStats->iters.push_back(it);
                    pStats->sims.push_back(itSim);
                    pStats->times.push_back(( std::clock() - start ) / (double) CLOCKS_PER_SEC);
                    idBest = idExp;
                    bestCost = cost;
                }
            }
        }
        if(ps.verbose)  printf("\n");
    }
    pStats->duration = ( std::clock() - start ) / (double) CLOCKS_PER_SEC;
    return idBest;
}

template<class NODE, template<class> class METHOD>
double mct_tree_t<NODE, METHOD>::evaluate( int id )
{
    for( auto trg : nodes[id].supportor.targets )
        if( !trg.isDone )   return -1;
    std::vector<NODE*> path;
    do
    {
        path.insert( path.begin(), &nodes[id] );
        id = nodes[id].idPar;
    } while ( id >= 0 );
    
    return method.evaluate( path );
}

template<class NODE, template<class> class METHOD>
std::vector<NODE> mct_tree_t<NODE, METHOD>::get_path( int id )
{
    std::vector<NODE> path;
    do
    {
        path.insert( path.begin(), nodes[id] );
        id = nodes[id].idPar;
    } while ( id >= 0 );
    
    return path;
}

template<class NODE, template<class> class METHOD>
void mct_tree_t<NODE, METHOD>::path_print( int id )
{
    if( id == -1 ) return;
    path_print( nodes[id].idPar );
    printf("=============================\n");
    printf("NODE %d\n", id);
    nodes[id].print();
} 

}// namespace mcts

} // namespace mockturtle