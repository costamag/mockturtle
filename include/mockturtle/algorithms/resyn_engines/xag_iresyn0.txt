/* mockturtle: C++ logic network library
 * Copyright (C) 2018-2022  EPFL
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/*!
  \file xag_resyn.hpp
  \brief Resynthesis by recursive decomposition for AIGs or XAGs.
  (based on ABC's implementation in `giaResub.c` by Alan Mishchenko)

  \author Siang-Yun Lee
*/

#pragma once

#include "../../utils/index_list.hpp"
#include "../../utils/node_map.hpp"
#include "../../utils/stopwatch.hpp"

#include <abcresub/abcresub.hpp>
#include <fmt/format.h>
#include <kitty/kitty.hpp>

#include <algorithm>
#include <optional>
#include <type_traits>
#include <vector>

namespace mockturtle
{

std::mt19937 rgen(5);

struct xag_iresyn_static_params
{
  using base_type = xag_iresyn_static_params;

  /*! \brief Maximum number of binate divisors to be considered. */
  static constexpr uint32_t max_binates{ 50u };

  /*! \brief Reserved capacity for divisor truth tables (number of divisors). */
  static constexpr uint32_t reserve{ 200u };

  /*! \brief Whether to consider single XOR gates (i.e., using XAGs instead of AIGs). */
  static constexpr bool use_xor{ true };

  /*! \brief Whether to copy truth tables. */
  static constexpr bool copy_tts{ false };

  /*! \brief Whether to preserve depth. */
  static constexpr bool preserve_depth{ false };

  /*! \brief Whether the divisors have uniform costs (size and depth, whenever relevant). */
  static constexpr bool uniform_div_cost{ true };

  /*! \brief Size cost of each AND gate. */
  static constexpr uint32_t size_cost_of_and{ 1u };

  /*! \brief Size cost of each XOR gate (only relevant when `use_xor = true`). */
  static constexpr uint32_t size_cost_of_xor{ 1u };

  /*! \brief Depth cost of each AND gate (only relevant when `preserve_depth = true`). */
  static constexpr uint32_t depth_cost_of_and{ 1u };

  /*! \brief Depth cost of each XOR gate (only relevant when `preserve_depth = true` and `use_xor = true`). */
  static constexpr uint32_t depth_cost_of_xor{ 1u };

  /*! \brief number of candidate supports */
  static constexpr uint32_t num_support_attempts{ 4u };

  /*! \brief maximum support size */
  static constexpr uint32_t max_supp_size{ 3u };

  /*! \brief number of candidate supports */
  static constexpr double beta{ 100 };

  using truth_table_storage_type = void;
  using node_type = void;
};

template<class TT>
struct xag_iresyn_static_params_default : public xag_iresyn_static_params
{
  using truth_table_storage_type = std::vector<TT>;
  using node_type = uint32_t;
};

template<class TT>
struct aig_iresyn_static_params_default : public xag_iresyn_static_params_default<TT>
{
  static constexpr bool use_xor = false;
};

template<class Ntk>
struct xag_iresyn_static_params_for_sim_resub : public xag_iresyn_static_params
{
  using truth_table_storage_type = incomplete_node_map<kitty::partial_truth_table, Ntk>;
  using node_type = typename Ntk::node;
};

template<class Ntk>
struct aig_iresyn_static_params_for_sim_resub : public xag_iresyn_static_params_for_sim_resub<Ntk>
{
  static constexpr bool use_xor = false;
};

struct xag_iresyn_stats
{
  /*! \brief Time for finding 0-resub and collecting unate literals. */
  stopwatch<>::duration time_unate{ 0 };

  /*! \brief Time for finding 1-resub. */
  stopwatch<>::duration time_resub1{ 0 };

  /*! \brief Time for finding 2-resub. */
  stopwatch<>::duration time_resub2{ 0 };

  /*! \brief Time for collecting the supports. */
  stopwatch<>::duration time_collect_supports{0};

  /*! \brief Time for finding spfd resub. */
  stopwatch<>::duration time_spfd{0};

  /*! \brief Time for finding 3-resub. */
  stopwatch<>::duration time_resub3{ 0 };

  /*! \brief Time for sorting unate literals and unate pairs. */
  stopwatch<>::duration time_sort{ 0 };

  /*! \brief Time for collecting unate pairs. */
  stopwatch<>::duration time_collect_pairs{ 0 };

  /*! \brief Time for dividing the target and recursive call. */
  stopwatch<>::duration time_divide{ 0 };

  void report() const
  {
    fmt::print( "[i]         <xag_iresyn_decompose>\n" );
    fmt::print( "[i]             0-resub      : {:>5.2f} secs\n", to_seconds( time_unate ) );
    fmt::print( "[i]             1-resub      : {:>5.2f} secs\n", to_seconds( time_resub1 ) );
    fmt::print( "[i]             2-resub      : {:>5.2f} secs\n", to_seconds( time_resub2 ) );
    fmt::print( "[i]             3-resub      : {:>5.2f} secs\n", to_seconds( time_resub3 ) );
    fmt::print( "[i]             sort         : {:>5.2f} secs\n", to_seconds( time_sort ) );
    fmt::print( "[i]             collect pairs: {:>5.2f} secs\n", to_seconds( time_collect_pairs ) );
    fmt::print( "[i]             dividing     : {:>5.2f} secs\n", to_seconds( time_divide ) );
  }
};

/*! \brief Logic iresynthesis engine for AIGs or XAGs.
 *
 * The algorithm is based on ABC's implementation in `giaResub.c` by Alan Mishchenko.
 *
 * Divisors are classified as positive unate (not overlapping with target offset),
 * negative unate (not overlapping with target onset), or binate (overlapping with
 * both onset and offset). Furthermore, pairs of binate divisors are combined with
 * an AND operation and considering all possible input polarities and again classified
 * as positive unate, negative unate or binate. Simple solutions of zero cost
 * (one unate divisor), one node (two unate divisors), two nodes (one unate divisor +
 * one unate pair), and three nodes (two unate pairs) are exhaustively examined.
 * When no simple solutions can be found, the algorithm heuristically chooses an unate
 * divisor or an unate pair to divide the target function with and recursively calls
 * itself to decompose the remainder function.
   \verbatim embed:rst

   Example

   .. code-block:: c++

      using TT = kitty::static_truth_table<6>;
      const std::vector<aig_network::node> divisors = ...;
      const node_map<TT, aig_network> tts = ...;
      const TT target = ..., care = ...;
      xag_iresyn_stats st;
      xag_iresyn_decompose<TT, node_map<TT, aig_network>, false, false, aig_network::node> iresyn( st );
      auto result = iresyn( target, care, divisors.begin(), divisors.end(), tts );
   \endverbatim
 */
template<class TT, class static_params = xag_iresyn_static_params_default<TT>>
class xag_iresyn_decompose
{
public:
  using stats = xag_iresyn_stats;
  using index_list_t = large_xag_index_list;
  using truth_table_t = TT;

private:
  struct unate_lit
  {
    unate_lit( uint32_t l )
        : lit( l )
    {}

    bool operator==( unate_lit const& other ) const
    {
      return lit == other.lit;
    }

    uint32_t lit;
    uint32_t score{ 0 };
  };

  struct fanin_pair
  {
    fanin_pair( uint32_t l1, uint32_t l2 )
        : lit1( l1 < l2 ? l1 : l2 ), lit2( l1 < l2 ? l2 : l1 )
    {}

    fanin_pair( uint32_t l1, uint32_t l2, bool is_xor )
        : lit1( l1 > l2 ? l1 : l2 ), lit2( l1 > l2 ? l2 : l1 )
    {
      (void)is_xor;
    }

    bool operator==( fanin_pair const& other ) const
    {
      return lit1 == other.lit1 && lit2 == other.lit2;
    }

    uint32_t lit1, lit2;
    uint32_t score{ 0 };
  };

public:
  explicit xag_iresyn_decompose( stats& st ) noexcept
      : st( st )
  {
    static_assert( std::is_same_v<typename static_params::base_type, xag_iresyn_static_params>, "Invalid static_params type" );
    static_assert( !( static_params::uniform_div_cost && static_params::preserve_depth ), "If depth is to be preserved, divisor depth cost must be provided (usually not uniform)" );
    divisors.reserve( static_params::reserve );
    probs.reserve( static_params::reserve );
  }

  /*! \brief Perform XAG iresynthesis.
   *
   * `tts[*begin]` must be of type `TT`.
   * Moreover, if `static_params::copy_tts = false`, `*begin` must be of type `static_params::node_type`.
   *
   * \param target Truth table of the target function.
   * \param care Truth table of the care set.
   * \param begin Begin iterator to divisor nodes.
   * \param end End iterator to divisor nodes.
   * \param tts A data structure (e.g. std::vector<TT>) that stores the truth tables of the divisor functions.
   * \param max_size Maximum number of nodes allowed in the dependency circuit.
   */
  template<class iterator_type,
           bool enabled = static_params::uniform_div_cost && !static_params::preserve_depth, typename = std::enable_if_t<enabled>>
  std::optional<index_list_t> operator()( TT const& target, TT const& care, iterator_type begin, iterator_type end, typename static_params::truth_table_storage_type const& tts, uint32_t max_size = std::numeric_limits<uint32_t>::max() )
  {
    static_assert( static_params::copy_tts || std::is_same_v<typename std::iterator_traits<iterator_type>::value_type, typename static_params::node_type>, "iterator_type does not dereference to static_params::node_type" );
    care_ = care;
    ptts = &tts;
    on_off_sets[0] = ~target & care;
    on_off_sets[1] = target & care;

    reset_masks();

    divisors.resize( 1 ); /* clear previous data and reserve 1 dummy node for constant */
    
    while ( begin != end )
    {
      if constexpr ( static_params::copy_tts )
      {
        divisors.emplace_back( ( *ptts )[*begin] );
      }
      else
      {
        divisors.emplace_back( *begin );
      }
      ++begin;
    }

    probs.resize( divisors.size() );

    return compute_function( max_size );
  }

  template<class iterator_type, class Fn,
           bool enabled = !static_params::uniform_div_cost && !static_params::preserve_depth, typename = std::enable_if_t<enabled>>
  std::optional<index_list_t> operator()( TT const& target, TT const& care, iterator_type begin, iterator_type end, typename static_params::truth_table_storage_type const& tts, Fn&& size_cost, uint32_t max_size = std::numeric_limits<uint32_t>::max() )
  {}

  template<class iterator_type, class Fn,
           bool enabled = !static_params::uniform_div_cost && static_params::preserve_depth, typename = std::enable_if_t<enabled>>
  std::optional<index_list_t> operator()( TT const& target, TT const& care, iterator_type begin, iterator_type end, typename static_params::truth_table_storage_type const& tts, Fn&& size_cost, Fn&& depth_cost, uint32_t max_size = std::numeric_limits<uint32_t>::max(), uint32_t max_depth = std::numeric_limits<uint32_t>::max() )
  {}

private:
  std::optional<index_list_t> compute_function( uint32_t num_inserts )
  {
    index_list.clear();
    index_list.add_inputs( divisors.size() - 1 );
    auto const lit = compute_function_rec( num_inserts );
    if ( lit )
    {
      assert( index_list.num_gates() <= num_inserts );
      index_list.add_output( *lit );
      return index_list;
    }
    return std::nullopt;
  }

  std::optional<uint32_t> compute_function_rec( uint32_t num_inserts )
  {
    pos_unate_lits.clear();
    neg_unate_lits.clear();
    binate_divs.clear();
    pos_unate_pairs.clear();
    neg_unate_pairs.clear();

    spfd_supports.clear();

    /* try 0-resub and collect unate literals */
    auto const res0 = call_with_stopwatch( st.time_unate, [&]() {
      return find_one_unate();
    } );
    if ( res0 )
    {
      return *res0;
    }
    if ( num_inserts == 0u )
    {
      return std::nullopt;
    }

    /* collect supports for spfd */
    call_with_stopwatch( st.time_collect_supports, [&]() {
      collect_supports();
    } );

    uint32_t k{0};
    for( uint32_t i{0}; i < spfd_supports.size(); ++i )
    {

    std::set<std::vector<uint32_t>>::iterator itr;
    for (itr = spfd_supports.begin(); itr != spfd_supports.end(); itr++)
    { 
      printf("%d:", k++);
      for( auto x : *itr )
        printf("%d ", x);
      printf("\n");
      if( itr->size() == 2u )
      {
        /* try spfd resub */
        auto const resSpfd2 = call_with_stopwatch( st.time_spfd, [&]() {
          return find_spfd2( *itr );
        } );
        if ( resSpfd2 )
        {
          return *resSpfd2;
        }
        if ( num_inserts == 0u )
        {
          return std::nullopt;
        }
      }
    }

    }

    return std::nullopt;
  }

  /* See if there is a constant or divisor covering all on-set bits or all off-set bits.
     1. Check constant-resub
     2. Collect unate literals
     3. Find 0-resub (both positive unate and negative unate) and collect binate (neither pos nor neg unate) divisors
   */
  std::optional<uint32_t> find_one_unate()
  {
    num_bits[0] = kitty::count_ones( on_off_sets[0] ); /* off-set */
    num_bits[1] = kitty::count_ones( on_off_sets[1] ); /* on-set */
    if ( num_bits[0] == 0 )
    {
      return 1;
    }
    if ( num_bits[1] == 0 )
    {
      return 0;
    }

    for ( auto v = 1u; v < divisors.size(); ++v )
    {
      /*  */
      bool unateness[4] = { false, false, false, false };
      /* check intersection with off-set */
      if ( kitty::intersection_is_empty<TT, 1, 1>( get_div( v ), on_off_sets[0] ) )
      {
        pos_unate_lits.emplace_back( v << 1 );
        unateness[0] = true;
      }
      else if ( kitty::intersection_is_empty<TT, 0, 1>( get_div( v ), on_off_sets[0] ) )
      {
        pos_unate_lits.emplace_back( v << 1 | 0x1 );
        unateness[1] = true;
      }

      /* check intersection with on-set */
      if ( kitty::intersection_is_empty<TT, 1, 1>( get_div( v ), on_off_sets[1] ) )
      {
        neg_unate_lits.emplace_back( v << 1 );
        unateness[2] = true;
      }
      else if ( kitty::intersection_is_empty<TT, 0, 1>( get_div( v ), on_off_sets[1] ) )
      {
        neg_unate_lits.emplace_back( v << 1 | 0x1 );
        unateness[3] = true;
      }

      /* 0-resub */
      if ( unateness[0] && unateness[3] )
      {
        return ( v << 1 );
      }
      if ( unateness[1] && unateness[2] )
      {
        return ( v << 1 ) + 1;
      }
      /* useless unate literal */
      if ( ( unateness[0] && unateness[2] ) || ( unateness[1] && unateness[3] ) )
      {
        pos_unate_lits.pop_back();
        neg_unate_lits.pop_back();
      }
      /* binate divisor */
      else if ( !unateness[0] && !unateness[1] && !unateness[2] && !unateness[3] )
      {
        binate_divs.emplace_back( v );
      }
    }
    return std::nullopt;
  }

  std::optional<uint32_t> choose_new_divisor( std::set<uint32_t> const& supp )
  {
    uint32_t iDiv;
    double n0m0, n1m0, n0m1, n1m1;
    double nEdges{0};
    for( auto m = 0u; m < nMasks; ++m )
    {
      if( ( (exhausted >> m) & 1u ) == 0u )
      {
        n1m1 = kitty::count_ones( on_off_sets[1] & masks[m] );
        n0m1 = kitty::count_ones( masks[m] ) - n1m1;
        nEdges += n1m1*n0m1;
      }
    }
    
    double Hmax = std::numeric_limits<double>::min();
    double Hmin = std::numeric_limits<double>::max();
    probs[0] = 0;
    for ( auto v = 1u; v < divisors.size(); ++v )
    {
      probs[v] = 0;
      if( supp.find( v ) == supp.end() )
      {
        for( auto m = 0u; m < nMasks; ++m )
        {
          if( ( (exhausted >> m) & 1u ) == 0u )
          {
            n1m1 = kitty::count_ones( on_off_sets[1] & get_div(v) & masks[m] );
            n0m1 = kitty::count_ones( get_div(v) & masks[m] ) - n1m1;
            n1m0 = kitty::count_ones( on_off_sets[1] & (~get_div(v)) & masks[m] );
            n0m0 = kitty::count_ones( (~get_div(v)) & masks[m] ) - n1m0;
            probs[v] += (n1m1*n0m1 + n1m0*n0m0)/nEdges;
          }
        }
        Hmin = probs[v] < Hmin ? probs[v] : Hmin;
        Hmax = probs[v] > Hmax ? probs[v] : Hmax;
      }
    }
    probs[0]=0;
    double Z{0};
    for ( auto v = 1u; v < divisors.size(); ++v )
    {
      if( supp.find( v ) == supp.end() )
        probs[v] = exp( -static_params::beta*((probs[v]-Hmin)/( Hmax-Hmin )) );
      else
        probs[v]=0;
      Z+=probs[v];
    }

    for ( auto v = 0u; v < divisors.size(); ++v )
      probs[v] /= Z;

    for ( auto v = 1u; v < divisors.size(); ++v )
    {
      probs[v] += probs[v-1];
      //printf("%f ", probs[v]);
    }
    //printf("\n");

    /* compute costs */

    /* compute probs */

    /* sample from probs */

    std::uniform_real_distribution<> distrib(0, 1);
    double rnd = distrib(rgen);
    //printf(" r(%f) ", rnd);

    iDiv=0;
    for( uint32_t i{1}; i<divisors.size(); ++i )
    {
        if( rnd <= probs[i] )
        {
            iDiv = i;
            break;
        }
    }
    //printf("->sel(%d)", iDiv);
    if( iDiv > 0 && ( supp.find( iDiv ) == supp.end() ) )
    {
    //  printf(" v\n");
      return iDiv;
    }
    //else
    //  printf("x\n");
    
    return std::nullopt;
  }



  void update_masks( uint32_t const& iDiv )
  {
    for( uint32_t iMask{0}; iMask < nMasks; ++iMask )
    {
      if( (( exhausted >> iMask ) & 1u) == 1u )
      {
        exhausted |=(1u << nMasks+iMask);
      }
      else
      {
        masks[nMasks+iMask] = masks[iMask] & get_div( iDiv );
        masks[iMask] = masks[iMask] & ~get_div( iDiv );

        if( kitty::count_ones( on_off_sets[1] & masks[nMasks+iMask] ) == 0 )
          exhausted |= (1u << (nMasks+iMask));
        else if( kitty::equal( on_off_sets[1] & masks[nMasks+iMask], masks[nMasks+iMask] ) )
          exhausted |= (1u << (nMasks+iMask));

        if( kitty::count_ones( on_off_sets[1] & masks[iMask] ) == 0 )
          exhausted |= (1u << iMask);
        else if( kitty::equal( on_off_sets[1] & masks[iMask], masks[iMask] ) )
          exhausted |= (1u << iMask);
      }
    }
    nMasks=nMasks*2;
  }

  void find_new_support()
  {
    reset_masks();
    std::set<uint32_t> sSupp;
    while( ( ( 1u << nMasks ) > (exhausted + 1) ) && (sSupp.size() < static_params::max_supp_size) ) 
    {
      /* sample from probability distribution */
      auto div = choose_new_divisor( sSupp );

      if( div )
      {
        //printf("chosen %d: supp =", *div);
        sSupp.insert( *div );
        update_masks( *div );
        //for ( auto itr = sSupp.begin(); itr != sSupp.end(); itr++)
        //  printf("%d ", *itr );
        //printf("\n");
      }
      else
        break;
    }

    if( (( 1<<nMasks ) - 1) == exhausted )
    {
      std::vector<uint32_t> vSupp(sSupp.begin(), sSupp.end());
      std::sort(vSupp.begin(), vSupp.end());
      spfd_supports.insert( vSupp );
    }
  }

  /* Collect supports using SPFDs.
   */
  void collect_supports()
  {
    int iter = static_params::num_support_attempts;
    while( iter-->0 )
    {
      find_new_support();
    }
  }


  std::optional<uint32_t> find_spfd2( std::vector<uint32_t> const& pSupp )
  {

  //  for ( auto i = 0u; i < unate_lits.size(); ++i )
  //  {
  //    uint32_t const& lit1 = unate_lits[i].lit;
  //    if ( unate_lits[i].score * 2 < num_bits[on_off] )
  //    {
  //      break;
  //    }
  //    for ( auto j = i + 1; j < unate_lits.size(); ++j )
  //    {
  //      uint32_t const& lit2 = unate_lits[j].lit;
  //      if ( unate_lits[i].score + unate_lits[j].score < num_bits[on_off] )
  //      {
  //        break;
  //      }
  //      auto const ntt1 = lit1 & 0x1 ? get_div( lit1 >> 1 ) : ~get_div( lit1 >> 1 );
  //      auto const ntt2 = lit2 & 0x1 ? get_div( lit2 >> 1 ) : ~get_div( lit2 >> 1 );
  //      if ( kitty::intersection_is_empty( ntt1, ntt2, on_off_sets[on_off] ) )
  //      {
  //        auto const new_lit = index_list.add_and( ( lit1 ^ 0x1 ), ( lit2 ^ 0x1 ) );
  //        return new_lit + on_off;
  //      }
  //    }
  //  }
    return std::nullopt;
  }

  inline TT const& get_div( uint32_t idx ) const
  {
    if constexpr ( static_params::copy_tts )
    {
      return divisors[idx];
    }
    else
    {
      return ( *ptts )[divisors[idx]];
    }
  }

protected:
  void reset_masks()
  {
    nMasks = 1u;
    exhausted = 0u;
    masks[0]=care_;
  }

private:
  std::array<TT, 2> on_off_sets;
  std::array<TT, 16> masks;
  uint32_t exhausted{0u};
  uint32_t nMasks{1};
  TT care_;

  std::array<uint32_t, 2> num_bits; /* number of bits in on-set and off-set */

  const typename static_params::truth_table_storage_type* ptts;
  std::vector<std::conditional_t<static_params::copy_tts, TT, typename static_params::node_type>> divisors;
  std::vector<double> probs;

  index_list_t index_list;

  /* positive unate: not overlapping with off-set
     negative unate: not overlapping with on-set */
  std::vector<unate_lit> pos_unate_lits, neg_unate_lits;
  std::vector<uint32_t> binate_divs;
  std::set<std::vector<uint32_t>> spfd_supports;
  std::vector<fanin_pair> pos_unate_pairs, neg_unate_pairs;

  stats& st;
}; /* xag_iresyn_decompose */

} /* namespace mockturtle */